# [架构300讲](https://www.bilibili.com/video/BV1WM4y1N79G/)

---
## 001/017 架构
- 不谈场景的架构设计都是耍流氓；架构没有对不对，只有合适不合适
- 尽量从问题的源头进行分析，在不增加系统复杂度的前提下解决问题
- 架构是宏观设计的标准；框架是具体实现的规则
- 解耦是架构设计无时无刻都要考虑的问题
- 尊重”爬 → 走 → 跑 → 跳“的自然规律，好的架构一定是演化而来的
### 大量文件读写过程中影响到服务器的磁盘 IO，导致数据库查询出现高延迟。如何优化？
1. Web 容器层面增加拦截器阻挡垃圾重复无效的请求穿透到数据库
2. 分析业务代码中 SQL 是否存在全表扫描以及索引选择性问题
3. 增加 InnoDB 引擎的 Buffer_Pool 让查询拥有更多的缓存命中率
4. 在操作系统层面，增加文件系统缓存，减少文件 IO 次数
---
## 002 MySQL 集群模式
1. 读写分离
    - 所有节点数据均保持同步
    - 适用于读多写少，单表不过千万的互联网应用
    - 配合 MHA 中间件实现高可用
```
                  +-----------+
                  | mall app  |
                  +-----------+
                        ↓
            +-----------------------+
            | Shardding Middleware  |
        ----|        [MyCat]        |----
        |   |   [ShardingSphere]    |   |
        |   +-----------|-----------+   |
      read            write            read
        |         +-----↓-----+         |
        |         | master-db |         |
        |         +-----|-----+         |
        ↓             binlog            ↓
    +-----------+       |       +-----------+
    | slave-db1 |←------+------→| slave-db2 |                 
    +-----------+               +-----------+
```
2. 分片（分库分表）
    - 每个节点数据是素有数据的子集
    - 适用于十亿级数据总量大型应用
    - 不具备高可用
```
                  +-----------+
                  | mall app  |
                  +-----------+
                        ↓
            +-----------------------+
            | Shardding Middleware  |
            |        [MyCat]        |
            |   [ShardingSphere]    |
            +-----------|-----------+
                      route
          +-------------+-------------+
    +-----↓-----+ +-----↓-----+ +-----↓-----+
    | master-db | | master-db | | master-db |
    |   shard   | |   shard   | |   shard   |
    +-----------+ +-----------+ +-----------+
```
3. 分片+读写分离
```
                  +-----------+
                  | mall app  |
                  +-----------+
                        ↓
            +-----------------------+
            | Shardding Middleware  |
            |        [MyCat]        |
            |   [ShardingSphere]    |
            +-----------|-----------+
                      route
          +-------------+-------------+
    +-----↓-----+ +-----↓-----+ +-----↓-----+
    | master-db | | master-db | | master-db |
    |   shard   | |   shard   | |   shard   |
    +-----------+ +-----------+ +-----------+
          ↓             ↓             ↓
    +-----------+ +-----------+ +-----------+
    | slave-db1 | | slave-db1 | | slave-db1 |
    +-----------+ +-----------+ +-----------+
    | slave-db2 | | slave-db2 | | slave-db2 |
    +-----------+ +-----------+ +-----------+
```
### 分片算法
1. 范围法
    - 适合范围检索
    - 数据分布不均匀，会产生“尾部热点”效应
    - 结构简单，扩展容易
    - 适用于流水账应用
```
    +---------------------------------------+
    |   +-----+      +-----+      +-----+   |  
    |   |1000-|      |3000-|      |5000-|   |
    |   |2000 |      |4000 |      |6000 |   |
    |   +-----+      +-----+      +-----+   |
    +---------------------------------------+
```
2. 哈希法
    - 类型：①取模；②一致性 Hash
    - 数据分布平均
    - 节点扩展复杂，数据迁移难度大；建议提前部署足够的节点
    - 适用于预算充足的大型互联网应用
```
    +---------------------------------------+
    |   +-----+      +-----+      +-----+   |
    |   |0,3,6|      |1,4,7|      |2,5,8|   |
    |   +-----+      +-----+      +-----+   |
    +---------------------------------------+
```
---
## 003 数据库垂直分表
- 垂直分表：将一张大表按列拆分为2张以上的小表，通过主外键关联来获取数据
- 为什么要垂直分表？：减少跨页检索，增加页内检索
- 原理：通过将重要字段单独剥离出一张小表，让每一页能够容纳更多的行，进而缩小数据扫描的范围，达到提高执行效率的目的
- 什么情况下考虑垂直分表？
    1. 单表数据量可能过千万
    2. 字段超过20个，且包含了超长的 Varchar、CLOB、BLOB 等字段
- 字段分配
    - 小表字段：高频访问的小字段、排序字段、逻辑删除字段等
    - 大表字段：低频访问字段、大字段
---
## 004 多级缓存
```
------------------------------------------------------------
         ------ static -----+----- sattic ------        客户端
         |     resource     ↓     resource     |
---------|---------------+-----+---------------|------------
         |               | CDN |               |        应用层
         |               +-----+               |
         |                  ↓                  |
         |              +-------+              |
         '- dynamic --→ | Nginx | ←-- dynamic -'
            access      +-------+      access
                            ↓
                  +--------------------+
                  | Tomcat App Cluster |
------------------+--------------------+--------------------
                            ↓                           服务层
                     +-------------+
                     | API Gateway |
                     +-------------+
         -------------------+-------------------
         ↓                  ↓                  ↓
    +---------+        +---------+        +---------+
    |  Goods  |        |  Order  |        |Logistics|
    | Service |        | Service |        | Service |
    | EhCache |        | EhCache |        | EhCache |
    +---------+        +-|-----|-+        +---------+
      |     |          read  write          |     |
      |     |    +-------↓-------------+    |     |
    write  read →|        Redis        |← read  write
      |          +---------------------+          |
------|------------↑-----↑-----|-----↑------------|---------
      ↓          Sync   Sync   ↓    Sync          ↓     数据层
  +-------------+  | +-------------+ |  +-------------+ 
  |  Goods  DB  |--' |  Order  DB  | '--|Logistics  DB|
  +-------------+    +-------------+    +-------------+
------------------------------------------------------------
```
1. [客户端](https://blog.csdn.net/weixin_39805244/article/details/126073670)
    - HTTP 缓存分为：①强制缓存 ②协商缓存，可在 CDN 或 Nginx 中设置
2. 应用层
    1. [CDN](https://mp.weixin.qq.com/s/g5YKer1b1sVrQT6cBTesQw)
    2. [Nginx](https://mp.weixin.qq.com/s/YgllTjNArUWdvgqBhAVWKQ)
3. 服务层
    1. 进程内缓存：Hibernate/Mybatis 缓存，Spring 缓存(EhCache 等)
    2. 进程外缓存：分布式缓存(Redis)
### 什么情况下适合引入多级缓存？
1. 缓存的数据是稳定的：邮政编码、地域区块、归档的历史数据等
2. 瞬时可能会产生极高并发的场景：12306 春运售票、双十一整点秒杀、股市开盘交易等
    - 热点数据缓存预热
3. 一定程度上允许数据不一致：博客自我介绍等
---
## 005/006 外包
- 项目外包 > 资源外包
- Java中级(18-27K)，Java高级(25-35K)
    - 中位数 * 60%：比如高级 30*60%=18K 
- 行业(10) > 项目(8) > 甲方(6)
    1. 行业：银行=互联网(100) > 保险/证券(80) > 传统行业(60) > 政府项目(40)
    2. 项目：核心应用(100) > 业务系统(80) > 数据应用(70) > 行政应用(20)
    3. 甲方：知名厂牌=四大或知名银行(100) > 小行(80) > 保险证券(70) > 知名其他企业(60) > 其他(40)
    - 例：华为外包X公司开发OA系统：(100*10+20*8+100*6)/100 = 17.6
---
## 007 大表禁用自增主键
1. 大表为什么不能使用自增主键？
    - 自增主键是数据库自带特性，只能做范围分片，会产生“尾部热点”效应
    - 数据迁移困难
2. UUID 为什么不是好的替代方案？
    - 128位，浪费空间
    - 无序，会引起索引重排
3. SnowFlake 雪花算法，@see [IdUtilDemo](../../../java/jar/hutool/util/IdUtilDemo.java)
    - 1++41+10+12=64位
        1. 第一部分：1位符号位，没有实际用处，只为了兼容长整型的格式
        2. 第二部分：41位时间戳，用来记录本地的毫秒时间
        3. 第三部分：10位 workId，即节点 ID，最大可达1024(2^10)个节点
        4. 第四部分：12位序列号，表示一个节点1毫秒能够产生的ID数量，即4096个(2^12)
    - 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或服务会处于不可用状态
---
## 008 布隆过滤器
```
                   id
           ---------+-----+-------
         hash            hash   hash
    +-----↓---------------↓-------↓-+
    | 0 | 1 | 0 | 0 | … | 1 |   | 1 |
    | 0 | 1 | 2 | 3 | … | 33| … |999|
    +-------------------------------+
```
- @see BloomFilterDemo
- 建议误判率为1%
- 如何减少误判：①增加二进制向量位数；②适当增加 Hash 次数
- 如何解决删除困难：①定时异步重建布隆过滤器；②计数布隆过滤器
- [Redis实现布隆过滤器（上）](https://cdn.modb.pro/db/566062)
- [Redis实现布隆过滤器（下）](https://cdn.modb.pro/db/566061)
---
## 009 [大厂禁用 IP 直连](https://blog.csdn.net/apple_56973763/article/details/122461841)
- 耦合问题：当 IP 更改的时候，大厂可能存在修改代码、重新测试、流程审批、预约上线时间等问题
- 如何解决？
    1. 内部 DNS
        - 优点：操作简单
        - 缺点：没有故障发现和转移，多 IP 只有轮询规则
    2. 注册中心：如 Nacos / Eureka
        - 优点：支持故障发现和转移，多种负载均衡规则
        - 缺点：架构复杂度增加
---
## 010 CAP 定理
- @see [NoSQL.md](../nosql/NoSQL.md)
```
订单系统(新建订单) → 库存系统(减少库存)
CP      订单创建后一直等待，库存减少后才返回结果            银行/金融/证券/互联网后端应用
AP      订单创建后不等待，库存减少直接后返回处理结果         互联网前端应用
AC                                                  单体应用
```
---
## 011 负载均衡器
- 解决的问题
    1. 高可用性
    2. 平均分配设备压力
    3. 支持故障发现和转移
- 类型
    - 软硬件：①硬件负载均衡；②软件负载均衡
    - 网络
    ```
                    四层负载均衡              七负载均衡
    执行效率            高                   相对较低
    作用协议        TCP(LVS/Nginx)      HTTP(Nginx), FTP, SMTP
    应用场景        实时应用集群              Web应用集群
    ```
- Nginx 五种负载均衡策略，@see [nginx_3.conf](../nginx/nginx_3.conf)
    1. 轮询（默认）
    2. 权重
    3. IP_HASH
    4. URL_HASH（第三方模块）
    5. FAIR（第三方模块）：哪个空闲，哪个处理
---
## 012 禁用外键
- @see [MySQL.md#SQL 语句-5](../sql/MySQL/MySQL.md)
1. 性能问题：额外的数据一致性校验查询
2. 并发问题：外键约束会启用行锁，主表写入时会进入阻塞
3. 级联删除问题：多层级级联删除会让数据变得不可控，触发器也被严格禁用
4. 数据耦合问题：数据库层面数据关系产生耦合，数据迁移维护困难
---
## 013 前后端分离
1. 纯后端页面渲染架构：JSP, Freemarker
    - 前端团队无法单独测试
    - 前后端职责不清，分工不明
    - 不具备多端应用的能力
2. 半分离架构：RestController 返回 JSON 数据，服务器存放 HTML/CSS/JS
    - 优点：
        - 前后端团队解耦
        - 后端 API 与数据重用
        - 应用渲染更灵活
        - 约定好接口与规范进行 Mock 开发
    - 缺点：可使用 应用网关 + Node.js 渲染页面 解决 ???
        - 前端失去动态性
        - 搜索引擎 SEO 不友好
---
## 014 [Canal](https://github.com/alibaba/canal)
- 基于数据库增量日志解析，提供增量数据订阅&消费
```
User Action     →   Master DB   →   Cannal          →   自动触发 Java 代码实现向 ES/MongoDB/… 同步
                    binlog          listen relaylog
Add User A          Insert …        Insert …
Delete User B       Delete …        Delete …
```
- Canal 解决了数据监听的问题，再引入 MQ 解决解耦的问题
```
+---------------------------+                                   +---------------+
| +-------+        +------+ |   insert   +----+  +- subscribe --| ElasticSearch | Team B 
| | MySQL |-listen→| Canal| |-- update -→| MQ |←-+              +---------------+
| +-------+        +------+ |   delete   +----+  +- subscribe --|    MongoDB    | Team C
+---------------------------+                                   +---------------+
            Team A
```
---
## 015 简历

---
## 016 MySQL MHA 高可用架构 ???
```
                            +-----+
                            | app |
                            +--|--+
                               IO
                            +--↓--+              +---------+
                            | VIP |              | slave1  |
                            +--|--+           --→| MHA node|
                               RW             |  +---------+
+---------+               +----↓----+         |  +---------+
|   MHA   |--- ping/3s --→| master  |-- Sync -+-→| slave2  |
| manager |   select 1    | MHA node|            | MHA node|
+---------+               +---------+            +---------+
```
- [mha4mysql-manager](htt ps://github.com/yoshinorim/mha4mysql-manager/wiki)
- 优点：
    1. 支持基于 GTID 的复制模式
    2. 提供了主从切换和故障转移功能，在线故障转移时不易丢失数据
    3. 同一个监控节点可以监控多个集群
- 缺点：
    1. 需要编写脚本或利用第三方工具来实现 VIP 的配置
    2. 只能监控主服务器是否可用，无法监控从服务器
    3. 需要基于 SSH 免认证登陆配置，存在一定的安全隐患
    4. 没有提供从服务器的读负载均衡功能
---
## 018/028 Redis 架构
- @see [Redis.md#复制](../interview/Redis.md)
- @see Redis.md#哨兵 → 高可用
- @see Redis.md#集群 → 高并发
---
## 019 Seata 分布式事务
- [三个角色](https://camo.githubusercontent.com/7ed522a514df2153b546a50af97b155d2163e30df937a69e5cb4cf04210d74eb/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353239363931373838312d32366661626562392d373166612d346633652d386137612d6663333137643333383966342e706e67)

| 角色    | 英文                      | 缩写  | 职责                                                  |
|-------|-------------------------|-----|-----------------------------------------------------|
| 事务管理器 | Transaction Manager     | TM  | 定义全局事务的作用域：开始/提交/回滚 全局事务                            |
| 事务协调者 | Transaction Coordinator | TC  | 维护全局和分支事务状态，驱动全局提交或回滚                               |
| 资源管理器 | Resource Manager        | RM  | 管理分支事务所运行的资源，与 TC 通信以注册分支事务并报告分支事务的状态，并驱动分支事务的提交或回滚 |
- 生命周期
    1. TM 要求 TC 开始一个新的全局事务。TC 生成一个表示全局事务的 XID。
    2. XID 通过微服务的调用链传播。
    3. RM 将本地事务注册为 XID 对应的全局事务的分支。
    4. TM 请求 TC 提交或回滚 XID 对应的全局事务。
    5. TC 驱动 XID 对应全局事务下的所有分支事务，完成分支提交或回滚。
- 四种模式：①AT；②TCC；③Saga；④XA
- [AT 模式](http://seata.io/zh-cn/docs/dev/mode/at-mode.html)
    1. 一阶段：立即提交业务逻辑事务和 UNDO_LOG 的事务
    2. 二阶段
        1. 回滚：根据 UNDO_LOG 生成并执行回滚语句
        2. 提交：TC 把分支提交请求放入异步任务队列中，并批量地删除 UNDO_LOG 记录
### Reference
- [seata](https://github.com/seata/seata)
- [seata-sampels](https://github.com/seata/seata-samples)
- [Seata Official Website](http://seata.io/en-us/)
---
## 020 接口幂等性
- 幂等表：无侵入的幂等解决方案
```
      +-----------------+
      |     Request     |               +-------------+
      |                 |--- RESTful --→| nginx + lua |
      | RequestId: 1234 |               +-------------+
      +-----------------+                      |
               ↑                        check RequestId
               |                        setnx 保证并发性
               |                               ↓
               |                    +---------------------+
+---------------------+             |        Redis        |                 +---------+
|     code: "201"     |             |                     |----------------→|         |
| message: "repeated" |←- OK/PROC --|  key : value : ttl  |                 |   APP   |
+---------------------+             |  SYS1-1234:OK:3min  |←----- AOP ------|         |
                                    | SYS1-1235:PROC:5min |  AfterReturning +---------+
                                    +---------------------+
```
---
## 021 锁
- @see [Concurrent.md](../../../java/knowledge/concurrent/Concurrent.md)
---
## 022 禁止三表关联
- @see [MySQL.md#避免使用子查询和 join](../sql/MySQL/MySQL.md)
- @see MySQL.md#索引规约-2
- 解决办法：
    1. 拆分成多条 SQL
    2. 反范式表
    3. 数据仓库/数据集市
---
## 023 禁用存储过程
- @see [MySQL.md#SQL 语句-6](../sql/MySQL/MySQL.md)
---
## 024/025 JWT
- @see [JoseJwtDemo](../../../java/jar/nimbusds/JoseJwtDemo.java)
- 应用方案

| 方案     | 说明                      | 适用应用      |
|--------|-------------------------|-----------|
| 网关统一校验 | JWT 校验无感知，验签过程无侵入，执行效率低 | 低并发企业级应用  |
| 应用认证方案 | 控制更加灵活，有一定代码侵入          | 追求性能互联网应用 |
- 令牌续签
    1. 不允许改变 Token 令牌：通过 Redis 有效期来实现 
        1. 距离超时 ≥ 1h，正常处理
        2. 距离超时 < 1h，正常处理，并增加超时时间 1h
        3. 已经超时，拒绝处理
    2. 允许改变 Token 令牌：生成两个超时时间不一样的 Token (access_token、refresh_token)
        1. access_token 未超时，正常处理
        2. access_token 超时，refresh_token 未超时，正常处理，并重新生成 Token
        3. Token 均超时，拒绝处理
- 解决重复生成 JWT 问题：用一个 Map<原JWT,新JWT> 记录过去 n 秒生成的 新JWT，当发现原JWT再次请求生成新JWT，则返回相同的新JWT 
---
## 026 公共表在分布式架构下如何访问
1. 公共表下沉为基础服务，各业务通过 RPC 访问
2. 自定义注解实现自动获取数据
```java
public class Bucket {
    private Long userId;
    private User user;
    @RC(name = "user-service", uri="/user/{userId}")
    public void setUser(User user) {
        return this.user = user;
    }
}
```
---
## 027 Web 高可用架构
```
                        www.abc.com
                             ↓
                      +-------------+
                      | DNS  Server |   
                      |  10.22.9.1  |
                      |  10.22.9.2  |
                      +-------------+
                             |
            +-- 10.22.9.1 ---+--- 10.22.9.2 --+
            |                                 |
    +-------↓---------------------------------↓-------+    
    |   +-------------+             +-------------+   |
    |   |    Nginx    |←--- VIP ---→|    Nginx    |   |
    |   | Keepalived  |             | Keepalived  |   |
    |   +-------------+             +-------------+   |
    +-------------------------------------------------+
                             ↓
    +-------------------------------------------------+    
    |   +---------+     +---------+     +---------+   |
    |   | Tomcat1 |     | Tomcat2 |     | Tomcat3 |   |
    |   +---------+     +---------+     +---------+   |
    +-------------------------------------------------+
```
- DNS 轮询的缺点（所以 DNS 不能直接指向 Tomcat）
    1. 只负载 IP 轮询获取，不保证节点可用
    2. DNS IP 列表变更有延时
    3. 外网 IP 占用严重
---
## 029/030 MySQL 脏读/不可重复读/幻读/MVCC
- @see [SQL.md#并发事务读取现象](../sql/SQL.md)
- [MySQL RR 如何解决幻读](https://www.zhihu.com/question/372905832)
    - 仅在第一次执行快照读(普通 select)时生成 ReadView，后续快照读会复用前面生成的 ReadView，所以不会幻读
    - 但如果是锁定读，ReadView 会重新生成，可能会产生幻读
---
## 026 公共表在分布式架构下如何访问
1. 公共表下沉为基础服务，各业务通过 RPC 访问
2. 自定义注解实现自动获取数据
```java
public class Bucket {
    private Long userId;
    private User user;
    @RC(name = "user-service", uri="/user/{userId}")
    public void setUser(User user) {
        return this.user = user;
    }
}
```
---
## 027 Web 高可用架构
```
                        www.abc.com
                             ↓
                      +-------------+
                      | DNS  Server |   
                      |  10.22.9.1  |
                      |  10.22.9.2  |
                      +-------------+
                             |
            +-- 10.22.9.1 ---+--- 10.22.9.2 --+
            |                                 |
    +-------↓---------------------------------↓-------+    
    |   +-------------+             +-------------+   |
    |   |    Nginx    |←--- VIP ---→|    Nginx    |   |
    |   | Keepalived  |             | Keepalived  |   |
    |   +-------------+             +-------------+   |
    +-------------------------------------------------+
                             ↓
    +-------------------------------------------------+    
    |   +---------+     +---------+     +---------+   |
    |   | Tomcat1 |     | Tomcat2 |     | Tomcat3 |   |
    |   +---------+     +---------+     +---------+   |
    +-------------------------------------------------+
```
- DNS 轮询的缺点（所以 DNS 不能直接指向 Tomcat）
    1. 只负载 IP 轮询获取，不保证节点可用
    2. DNS IP 列表变更有延时
    3. 外网 IP 占用严重
---
## 029/030 MySQL 脏读/不可重复读/幻读/MVCC
- @see [SQL.md#并发事务读取现象](../sql/SQL.md)
- [MySQL RR 如何解决幻读](https://www.zhihu.com/question/372905832)
    - 仅在第一次执行快照读(普通 select)时生成 ReadView，后续快照读会复用前面生成的 ReadView，所以不会幻读
    - 但如果是锁定读，ReadView 会重新生成，可能会产生幻读
---
## 031 微服务
- 分布式架构发展过程
    1. 单体阶段
    2. 垂直拆分阶段：按业务模块拆分
        - 各业务模块仍连接同一数据库
    3. RPC 通信阶段：解决数据层面上的耦合
        - 生产者和消费者存在强代码依赖
        - 异构系统继承不友好
    4. ESB 服务总线阶段
    5. 微服务：一种将单个应用程序开发为一组小型服务，每个服务运行在自己的进程中，并以轻量级的机制（HTTP RESTful API）的方式进行通信。这些服务围绕着业务能力所建立的，并且可以由完全自动化的部署机构独立部署。这些服务的集中管理只有最低限度，可以使用不同的编程语言编写并使用不同的数据库存储技术。
---
## 032/033 Docker
- @see [Docker.md](../docker/Docker.md)
- 应用部署发展过程
    1. 物理机时代：部署慢、成本高、资源浪费、扩展迁移难、受限于硬件
    2. 虚拟机时代：
        - 优点：多部署、扩展相对容易
        - 缺点：资源隔离、VM 需要安装操作系统
    3. 容器化时代：标准化的迁移方式、统一的参数配置、自动化部署、应用集群监控、开发与运维之间的沟通桥梁
---
